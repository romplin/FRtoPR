# Feature Request App - Repository Structure & Build Guide

## Repository Structure

Your repository should look like this:

```
feature-request-app/
├── main.go                 # Main application file (Go backend + Vue frontend)
├── go.mod                  # Go module file
├── go.sum                  # Go dependencies (auto-generated)
├── Dockerfile              # Docker build configuration
├── docker-compose.yml      # Docker Compose configuration
├── .env.example           # Environment variables template
├── .env                   # Your actual environment variables (git-ignored)
├── .gitignore             # Git ignore file
├── Makefile               # Build automation
├── README.md              # Project documentation
├── .github/
│   └── workflows/
│       └── deploy.yml     # Complete CI/CD pipeline
└── configs/               # Optional: configuration files
    ├── nginx.conf         # Nginx reverse proxy config
    └── feature-request-app.service  # Systemd service file
```

## Step-by-Step Build Instructions

### 1. Initialize Your Repository

```bash
# Create project directory
mkdir feature-request-app
cd feature-request-app

# Initialize Git repository
git init

# Initialize Go module
go mod init feature-request-app
```

### 2. Create Core Files

Create these files in order:

#### `main.go`
Copy the complete Go application code from the artifact above.

#### `go.mod`
```go
module feature-request-app

go 1.21

require (
    // No external dependencies - using only Go standard library
)
```

#### `.gitignore`
```
# Binaries
feature-request-app
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool
*.out

# Go workspace file
go.work

# Environment variables
.env

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Docker
.dockerignore

# Logs
*.log
```

#### `.env.example`
```bash
# GitHub MCP Server Configuration
GITHUB_MCP_SERVER_URL=https://your-github-mcp-server.com
GITHUB_MCP_TOKEN=your-github-mcp-token

# Server Configuration
PORT=8080
```

#### `Dockerfile`
```dockerfile
# Multi-stage build for smaller final image
FROM golang:1.21-alpine AS builder

# Set working directory
WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# Final stage - minimal image
FROM alpine:latest

# Install ca-certificates for HTTPS requests
RUN apk --no-cache add ca-certificates

# Create non-root user
RUN addgroup -g 1001 -S app && \
    adduser -S -D -H -u 1001 -h /app -s /sbin/nologin -G app -g app app

WORKDIR /app

# Copy binary from builder stage
COPY --from=builder /app/main .

# Change ownership to app user
RUN chown app:app main

# Switch to non-root user
USER app

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# Run the application
CMD ["./main"]
```

#### `docker-compose.yml`
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - PORT=8080
      - GITHUB_MCP_SERVER_URL=${GITHUB_MCP_SERVER_URL}
      - GITHUB_MCP_TOKEN=${GITHUB_MCP_TOKEN}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

#### `Makefile`
```makefile
.PHONY: build run clean docker-build docker-run deploy test fmt lint help

# Variables
BINARY_NAME=feature-request-app
DOCKER_IMAGE=feature-request-app
PORT=8080

# Default target
help: ## Show this help message
	@echo 'Usage: make [target]'
	@echo ''
	@echo 'Targets:'
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  %-15s %s\n", $$1, $$2}' $(MAKEFILE_LIST)

# Development
build: ## Build the Go application
	@echo "Building $(BINARY_NAME)..."
	go mod tidy
	go build -o $(BINARY_NAME) .

run: ## Run the application locally
	@echo "Running $(BINARY_NAME) on port $(PORT)..."
	go run main.go

dev: ## Run in development mode with auto-reload (requires air)
	@if command -v air > /dev/null; then \
		air; \
	else \
		echo "Install air for auto-reload: go install github.com/cosmtrek/air@latest"; \
		make run; \
	fi

# Testing
test: ## Run tests
	go test -v ./...

test-coverage: ## Run tests with coverage
	go test -v -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out -o coverage.html

# Code quality
fmt: ## Format Go code
	go fmt ./...

lint: ## Run linter (requires golangci-lint)
	@if command -v golangci-lint > /dev/null; then \
		golangci-lint run; \
	else \
		echo "Install golangci-lint: https://golangci-lint.run/usage/install/"; \
	fi

# Docker
docker-build: ## Build Docker image
	@echo "Building Docker image $(DOCKER_IMAGE)..."
	docker build -t $(DOCKER_IMAGE):latest .

docker-run: ## Run Docker container
	@echo "Running Docker container..."
	docker run -p $(PORT):$(PORT) --env-file .env $(DOCKER_IMAGE):latest

docker-compose-up: ## Start with docker-compose
	docker-compose up -d

docker-compose-down: ## Stop docker-compose
	docker-compose down

docker-logs: ## View docker-compose logs
	docker-compose logs -f

# Deployment
deploy: ## Manual deployment (for local testing)
	@echo "Use 'git push' to trigger GitHub Actions deployment"
	@echo "Or run: gh workflow run deploy-hetzner.yml"

# Cleanup
clean: ## Clean build artifacts
	@echo "Cleaning up..."
	rm -f $(BINARY_NAME)
	rm -f coverage.out coverage.html
	docker image prune -f

# Setup
setup: ## Set up development environment
	@echo "Setting up development environment..."
	cp .env.example .env
	@echo "Please edit .env with your configuration"
	go mod tidy

# Production helpers
build-prod: ## Build for production
	CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags '-w -s' -o $(BINARY_NAME) .

install-tools: ## Install development tools
	go install github.com/cosmtrek/air@latest
	go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
```

#### `.github/workflows/deploy.yml`
```yaml
name: Complete CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * 1'  # Weekly security scan on Monday at 2 AM
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      skip_tests:
        description: 'Skip tests (emergency deploy)'
        required: false
        default: false
        type: boolean

env:
  GO_VERSION: 1.21
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ================================================================
  # TESTING & CODE QUALITY
  # ================================================================
  test:
    runs-on: ubuntu-latest
    if: ${{ !github.event.inputs.skip_tests }}
    outputs:
      should_deploy: ${{ steps.check_deploy.outputs.should_deploy }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Run tests
      run: go test -v ./...

    - name: Run go vet
      run: go vet ./...

    - name: Check code formatting
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "❌ The following files are not formatted:"
          gofmt -s -l .
          exit 1
        fi
        echo "✅ Code formatting is correct"

    - name: Build application
      run: |
        CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags '-w -s' -o feature-request-app .

    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: feature-request-app-${{ github.sha }}
        path: feature-request-app
        retention-days: 30

    - name: Check if should deploy
      id: check_deploy
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "should_deploy=true" >> $GITHUB_OUTPUT
        else
          echo "should_deploy=false" >> $GITHUB_OUTPUT
        fi

  # ================================================================
  # SECURITY SCANNING
  # ================================================================
  security:
    runs-on: ubuntu-latest
    permissions:
      security-events: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy filesystem scan
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-fs-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-fs-results.sarif'

  # ================================================================
  # DOCKER BUILD & PUBLISH
  # ================================================================
  docker:
    needs: [test, security]
    if: ${{ always() && (needs.test.outputs.should_deploy == 'true' || github.event.inputs.skip_tests == 'true') }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Run Trivy image scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        format: 'sarif'
        output: 'trivy-image-results.sarif'

    - name: Upload Trivy image scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-image-results.sarif'

  # ================================================================
  # DEPLOY TO HETZNER
  # ================================================================
  deploy:
    needs: [docker]
    if: ${{ github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
    - name: Deploy to Hetzner Server
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.HETZNER_HOST }}
        username: ${{ secrets.HETZNER_USERNAME }}
        key: ${{ secrets.HETZNER_SSH_KEY }}
        port: ${{ secrets.HETZNER_PORT || 22 }}
        script: |
          # Deployment configuration
          DEPLOY_DIR="/opt/feature-request-app"
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          BACKUP_DIR="/opt/backups/feature-request-app"
          
          echo "🚀 Starting deployment..."
          echo "📦 Image: $IMAGE_NAME"
          echo "📁 Deploy directory: $DEPLOY_DIR"
          
          # Create directories
          sudo mkdir -p $DEPLOY_DIR $BACKUP_DIR
          cd $DEPLOY_DIR
          
          # Backup current deployment
          if [ -f docker-compose.yml ]; then
            echo "💾 Creating backup..."
            sudo cp docker-compose.yml $BACKUP_DIR/docker-compose-$(date +%Y%m%d-%H%M%S).yml
          fi
          
          # Login to registry
          echo "🔐 Logging into container registry..."
          echo "${{ secrets.GITHUB_TOKEN }}" | sudo docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
          
          # Pull latest image
          echo "⬇️ Pulling latest image..."
          sudo docker pull $IMAGE_NAME
          
          # Stop existing containers gracefully
          echo "🛑 Stopping existing containers..."
          sudo docker-compose down --timeout 30 2>/dev/null || true
          
          # Create new docker-compose.yml
          echo "📝 Creating docker-compose configuration..."
          sudo tee docker-compose.yml > /dev/null <<EOF
          version: '3.8'
          services:
            app:
              image: $IMAGE_NAME
              ports:
                - "8080:8080"
              environment:
                - PORT=8080
                - GITHUB_MCP_SERVER_URL=${{ secrets.GITHUB_MCP_SERVER_URL }}
                - GITHUB_MCP_TOKEN=${{ secrets.GITHUB_MCP_TOKEN }}
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
              labels:
                - "deployment.version=${{ github.sha }}"
                - "deployment.timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          EOF
          
          # Start new containers
          echo "▶️ Starting new containers..."
          sudo docker-compose up -d
          
          # Wait for health check
          echo "🏥 Waiting for application to be healthy..."
          max_attempts=30
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            if curl -f http://localhost:8080/health > /dev/null 2>&1; then
              echo "✅ Application is healthy!"
              break
            fi
            attempt=$((attempt + 1))
            echo "⏳ Health check attempt $attempt/$max_attempts..."
            sleep 2
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "❌ Health check failed, rolling back..."
            sudo docker-compose down
            if [ -f $BACKUP_DIR/docker-compose-*.yml ]; then
              latest_backup=$(ls -t $BACKUP_DIR/docker-compose-*.yml | head -n1)
              sudo cp "$latest_backup" docker-compose.yml
              sudo docker-compose up -d
            fi
            exit 1
          fi
          
          # Cleanup old images
          echo "🧹 Cleaning up old images..."
          sudo docker image prune -f
          
          # Show deployment status
          echo "📊 Deployment Status:"
          sudo docker-compose ps
          
          echo "🎉 Deployment completed successfully!"
          echo "🌐 Application URL: http://${{ secrets.HETZNER_HOST }}:8080"

    - name: Verify deployment
      run: |
        echo "🔍 Verifying deployment..."
        sleep 10
        
        response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.HETZNER_HOST }}:8080/health)
        if [ $response -eq 200 ]; then
          echo "✅ External health check passed!"
        else
          echo "❌ External health check failed with status: $response"
          exit 1
        fi

  # ================================================================
  # NOTIFICATION & CLEANUP
  # ================================================================
  notify:
    needs: [test, security, docker, deploy]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Deployment Success Notification
      if: ${{ needs.deploy.result == 'success' }}
      run: |
        echo "🎉 Deployment successful!"
        echo "📋 Summary:"
        echo "  - Environment: ${{ github.event.inputs.environment || 'production' }}"
        echo "  - Commit: ${{ github.sha }}"
        echo "  - Image: ${{ needs.docker.outputs.image_tag }}"
        echo "  - URL: http://${{ secrets.HETZNER_HOST }}:8080"

    - name: Deployment Failure Notification
      if: ${{ needs.deploy.result == 'failure' }}
      run: |
        echo "❌ Deployment failed!"
        echo "📋 Failed jobs:"
        echo "  - Test: ${{ needs.test.result }}"
        echo "  - Security: ${{ needs.security.result }}"
        echo "  - Docker: ${{ needs.docker.result }}"
        echo "  - Deploy: ${{ needs.deploy.result }}"
        exit 1

    - name: Test Failure Notification
      if: ${{ needs.test.result == 'failure' }}
      run: |
        echo "❌ Tests failed - deployment skipped"
        exit 1
```

#### `README.md`
```markdown
# Feature Request System

A modern Go + Vue.js application for capturing and managing structured feature requests with GitHub MCP integration.

## 🚀 Quick Start

1. **Clone and setup**:
   ```bash
   git clone <your-repo-url>
   cd feature-request-app
   make setup
   ```

2. **Configure environment**:
   ```bash
   # Edit .env with your settings
   nano .env
   ```

3. **Run locally**:
   ```bash
   make run
   # or with Docker
   make docker-compose-up
   ```

4. **Visit**: http://localhost:8080

## 🛠️ Development

### Prerequisites
- Go 1.21+
- Docker & Docker Compose
- Make

### Available Commands
```bash
make help          # Show all available commands
make run           # Run locally
make build         # Build binary
make test          # Run tests
make docker-build  # Build Docker image
make deploy        # Deploy to production
```

### Project Structure
- `main.go` - Single-file application (Go backend + Vue frontend)
- `Dockerfile` - Multi-stage Docker build
- `docker-compose.yml` - Container orchestration
- `Makefile` - Build automation
- `deploy.sh` - Deployment script

## 🔧 Configuration

Environment variables in `.env`:
```bash
GITHUB_MCP_SERVER_URL=https://your-github-mcp-server.com
GITHUB_MCP_TOKEN=your-token
PORT=8080
```

## 🚢 Deployment with GitHub Actions

### Setup GitHub Secrets

In your GitHub repository settings, add these secrets:

**Required for Hetzner deployment:**
- `HETZNER_HOST` - Your Hetzner server IP/domain
- `HETZNER_USERNAME` - SSH username (usually `root`)
- `HETZNER_SSH_KEY` - Your private SSH key
- `HETZNER_PORT` - SSH port (usually `22`)

**Required for GitHub MCP:**
- `GITHUB_MCP_SERVER_URL` - Your GitHub MCP server URL
- `GITHUB_MCP_TOKEN` - Your GitHub MCP token

### Automated Deployment

#### Automatic (on push to main):
```bash
git add .
git commit -m "Deploy new version"
git push origin main
# GitHub Actions will automatically deploy to Hetzner
```

#### Manual deployment:
```bash
# Using GitHub CLI
gh workflow run deploy-hetzner.yml

# Or trigger from GitHub web interface
# Go to Actions → Deploy to Hetzner → Run workflow
```

### Workflow Features

✅ **Complete Pipeline** (single `deploy.yml`):
- **Testing** - Go tests, code quality, and formatting
- **Security** - Filesystem and Docker image scanning
- **Building** - Docker images with multi-arch support
- **Deployment** - Automated Hetzner deployment with rollback
- **Monitoring** - Health checks and notifications

### Trigger Options

**Automatic triggers:**
- 📤 **Push to main** - Full CI/CD pipeline
- 🔄 **Pull requests** - Testing only (no deployment)
- 📅 **Weekly** - Security scans

**Manual triggers:**
- 🎯 **Manual deployment** with environment selection
- 🚨 **Emergency deploy** with skip tests option

## 📊 Features

- ✅ Clean Vue.js frontend with reactive UI
- ✅ Go backend with RESTful API
- ✅ Structured feature request forms
- ✅ GitHub MCP integration
- ✅ Docker support
- ✅ Health checks
- ✅ Production-ready deployment

## 🔍 API Endpoints

- `GET /` - Frontend application
- `POST /api/submit` - Submit feature request
- `GET /api/requests` - List all requests
- `GET /health` - Health check

## 📝 License

MIT License
```

## 3. Build and Run Instructions

### Local Development:
```bash
# 1. Set up the project
make setup

# 2. Edit your .env file
nano .env

# 3. Run locally
make run
# or
go run main.go
```

### Docker Development:
```bash
# Build and run with Docker
make docker-build
make docker-run

# Or use docker-compose
make docker-compose-up
```

### Production Deployment:
```bash
# On your Hetzner server
git clone <your-repo>
cd feature-request-app
cp .env.example .env
# Edit .env with your actual values
make deploy
```

## 4. Quick Commands Reference

```bash
# Development
make run              # Run locally
make build            # Build binary
make test             # Run tests
make fmt              # Format code

# Docker
make docker-build     # Build image
make docker-compose-up # Start with compose
make docker-logs      # View logs

# GitHub Actions
git push              # Trigger full CI/CD
gh workflow run deploy.yml --field environment=staging  # Deploy to staging
gh workflow run deploy.yml --field skip_tests=true      # Emergency deploy
```

This structure gives you a complete, production-ready repository with proper build automation, deployment scripts, and documentation. The single `main.go` file contains everything you need, making it easy to maintain while still being feature-complete!
